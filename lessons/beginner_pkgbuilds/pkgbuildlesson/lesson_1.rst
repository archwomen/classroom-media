Beginners Guide to PKGBUILDS, Lesson 1
**************************************

Overview
========

Packages in Arch Linux are built using the ``makepkg`` utility and the
information stored in a ``PKGBUILD`` file. When ``makepkg`` is run, it
searches for a ``PKGBUILD`` in the current directory and follows the
instructions therein to either compile or otherwise acquire the required
files to be packaged within a package file ``pkgname.pkg.tar.xz``). The
resulting package contains binary files and installation instructions;
readily installed with ``pacman``.

An Arch package is no more than a tar archive, or ``tarball``, compressed
using xz, which contains the following files generated by makepkg:

* The binary files to install.
* ``.PKGINFO`` contains all the metadata needed by pacman to deal with
  packages, dependencies, etc.
* ``.INSTALL`` an optional file used to execute commands after the
  install/upgrade/remove stage. (This file is present only if specified
  in the ``PKGBUILD``.)
* ``.Changelog`` an optional file kept by the package maintainer
  documenting the changes of the package. (It is not present in all
  packages.)

Preparation
===========

Prerequisite software
---------------------

First ensure that the necessary tools are installed. The package group 
`base-devel`_ should be sufficient; it includes ``make`` and
additional tools needed for compiling from source::

    # pacman -S base-devel

One of the key tools for building packages is ``makepkg`` (provided by
``pacman``) which does the following:

* Checks if package dependencies are installed.
* Downloads the source file(s) from the specified server(s).
* Unpacks the source file(s).
* Compiles the software and installs it under a fakeroot environment.
* Strips symbols from binaries and libraries.
* Generates the package meta file which is included with each package.
* Compresses the fakeroot environment into a package file.
* Stores the package file in the configured destination directory, which
  is the present working directory by default.

Download and test the installation
----------------------------------

Download the source tarball of the software you want to package, extract
it, and follow the author's steps to install the program.  Make a note of
all commands and/or steps needed to compile and install it. You will be
repeating those same commands in the ``PKGBUILD`` file.

Most software authors stick to the 3-step build cycle::

    $ ./configure
    $ make
    # make install

This is a good time to make sure the program is working correctly.

Creating a PKGBUILD
-------------------

When you run ``makepkg``, it will look for a ``PKGBUILD`` file in the
present working directory. If a ``PKGBUILD`` file is found it will
download the software's source code and compile it according to the
instructions specified in the ``PKGBUILD`` file. The instructions must
be fully interpretable by the Bash shell. After successful completion,
the resulting binaries and metadata of the package, i.e. package version
and dependencies, are packed in a ``pkgname.pkg.tar.xz`` package
file that can be installed with ``pacman -U <package file>``.

To begin with a new package, you should first create an empty working
directory, (preferably ``~/abs/pkgname``), change into that directory,
and create a ``PKGBUILD`` file.  You can either copy the prototype PKGBUILD
``/usr/share/pacman/PKGBUILD.proto`` to your working directory or copy a
``PKGBUILD`` from a similar package. The latter may be useful if you only
need to change a few options.

Defining PKGBUILD variables
---------------------------

Example PKGBUILDs are located in ``/usr/share/pacman/``. An explanation of
possible ``PKGBUILD`` variables can be found in the `PKGBUILD article`_.

``makepkg`` defines three variables that you should use as part of the build and install process:

* ``startdir``

  This contains the absolute path to the directory where the ``PKGBUILD``
  file is located. This variable used to be used in combination with ``/src``
  or ``/pkg`` postfixes, but the use of ``srcdir`` and ``pkgdir`` variables
  is the modern method. ``$startdir/src`` is *not* guaranteed to be the same
  as ``$srcdir``, and likewise for ``$pkgdir``. Use of this variable is
  deprecated and strongly discouraged.

* ``srcdir``
  
  This points to the directory where ``makepkg`` extracts or copies all
  source files.

* ``pkgdir``
  
  This points to the directory where ``makepkg`` bundles the installed
  package, which becomes the root directory of your built package.

.. note::
  ``makepkg``, and thus the ``build()`` and ``package()`` functions, are
  intended to be non-interactive.  Interactive utilities or scripts called
  in those functions may break ``makepkg``, particularly if it is invoked
  with build-logging enabled (``-l``). (See `bug 13214`_.)

.. note::
  Apart from the current package Maintainer, there may be previous
  maintainers listed above as Contributors.

The ``build()`` function
------------------------

Now you need to implement the ``build()`` function in the ``PKGBUILD`` file.
This function uses common shell commands in `Bash`_ syntax to automatically
compile software and create a ``pkg`` directory to install the software to.
This allows ``makepkg`` to package files without having to sift through
your filesystem.

The first step in the ``build()`` function is to change into the directory
created by uncompressing the source tarball.  In most common cases the
first command will look like this::

    $ cd "$srcdir/$pkgname-$pkgver"

Now, you need to list the same commands you used when you manually compiled
the software.  The ``build()`` function in essence automates everything you
did by hand and compiles the software in the fakeroot build environment.
If the software you are packaging uses a configure script, it is good
practice to use ``1=--prefix=/usr`` when building packages for ``pacman``.
A lot of software installs files relative to the ``/usr/local`` directory,
which should only be done if you are manually building from source.  All
Arch Linux packages should use the ``/usr`` directory.  As seen in the
``/usr/share/pacman/PKGBUILD.proto`` file, the next two lines often look
like this::

    $ ./configure --prefix=/usr
    $ make

.. note::
  If your software does not need to build anything, DO NOT use the
  ``build()`` function. It is not required, but the ``package()`` function
  is.

The ``check()`` function
------------------------

Place for calls to ``make check`` and similar testing routines. Users who
don't need it (and occasionally maintainers who can not fix a package for
this to pass) can disable it using ``!check`` in PKGBUILD/makepkg options.

The ``package()`` function
--------------------------

The final step is to put the compiled files in a directory where
``makepkg`` can retrieve them to create a package.  This by default is the
``pkg`` directoryâ€”a simple fakeroot environment.  The ``pkg`` directory
replicates the hierarchy of the root file system of the software's
installation paths. If you have to manually place files under the root of
your filesystem, you should install them in the ``pkg`` directory under the
same directory structure.  For example, if you want to install a file to 
``/usr/bin``, it should instead be placed under ``$pkgdir/usr/bin``. Very
few install procedures require the user to copy dozens of files manually. 
Instead, for most software, calling ``make install`` will do so.  The final
line should look like the following in order to correctly install the
software in the ``pkg`` directory::

    # make DESTDIR="$pkgdir/" install

.. note::
  It is sometimes the case where ``DESTDIR`` is not used in the
  ``Makefile``; you may need to use ``prefix`` instead. If the package
  is built with ``autoconf``/``automake``, use ``DESTDIR``; this is what
  is `documented`_ in the manuals. If ``DESTDIR`` does not work, try
  building with ``1=make prefix="$pkgdir/usr/" install``. If that does not
  work, you will have to look further into the install commands that are
  executed by ``make <...> install``.

In some odd cases, the software expects to be run from a single directory.
In such cases, it is wise to simply copy these to ``$pkgdir/opt``.

More often than not, the installation process of the software will create
any sub-directories below the ``pkg`` directory. If it does not, however,
``makepkg`` will generate a lot of errors and you will need to manually
create sub-directories by adding the appropriate ``mkdir -p`` commands in
the ``build()`` function before the installation procedure is run.

In old packages, there was no ``package()`` function. So, files were put
into the ``pkg`` directory at the end of the ``build()`` function. If
``package()`` is not present, ``build()`` runs via ``fakeroot``. In new
packages, ``package()`` is required and runs via ``fakeroot`` instead, and
``build()`` runs without any special privileges. 

``makepkg --repackage`` runs only the ``package()`` function, so it creates
a ``*.pkg.*`` file without compiling the package. This may save time e.g.
if you just have changed the ``depends`` variable of the package.

.. note::
  The package() function is the only required function in a PKGBUILD.
  If you must only copy files into their respective directories to install a
  program, do not put it in the build() function, put that in the
  ``package()`` function.

The prepare() function (pacman >=4.1)
-------------------------------------

Pacman 4.1 introduces the prepare() command. In this function commands that
are used to prepare sources for building are run, such as patch or
configuring. This function is run before the build function and after the
package extraction. If extraction is skipped (``makepkg -e``), then
``prepare()`` is not run. 

.. note::
  (From ``man PKGBUILD``) The function is run in bash -e mode, meaning any
  command that exits with a non-zero status will cause the function to exit.

The pkgver() function (pacman >= 4.1)
-------------------------------------

Beginning with pacman 4.1 (currently in the development version), you can
update the pkgver variable during a makepkg. ``pkgver()`` is run right
after the sources are fetched and extracted.

This is particularly useful if you are making git/svn/hg/etc. packages,
where the build process may remain the same, but the source could be updated
every day, even every hour. The old way of doing this was to put the date
into the pkgver field which, if the software was not updated, makepkg would
still rebuild it thinking the version had changed. Some useful commands for
this are ``git describe``, ``hg identify -ni``, etc. Please test these
before submitting a PKGBUILD, as a failure in the ``pkgver()`` function can
stop a build in it's tracks. 

.. note::
  pkgver cannot contain spaces or ``-``'s. Using ``sed`` to correct this is
  common.

Testing the ``PKGBUILD`` and package
====================================

As you are writing the ``build()`` function, you will want to test your
changes frequently to ensure there are no bugs. You can do this using the
``makepkg`` command in the directory containing the ``PKGBUILD`` file. With
a properly formatted ``PKGBUILD``, makepkg will create a package; with a
broken or unfinished ``PKGBUILD``, it will raise an error.

If makepkg finishes successfully, it will place a file named
``pkgname-pkgver.pkg.tar.xz`` in your working directory. This package can
be installed with the ``pacman -U`` command. However, just because a package
file was built does not imply that it is fully functional. It might
conceivably contain only the directory and no files whatsoever if, for
example, a prefix was specified improperly. You can use pacman's query
functions to display a list of files contained in the package and the
dependencies it requires with ``pacman -Qlp [package file]`` and
``pacman -Qip [package file]`` respectively.

If the package looks sane, then you are done! However, if you plan on
releasing the ``PKGBUILD`` file, it is imperative that you check and
double-check the contents of the ``depends`` array. 

Also ensure that the package binaries actually ``run`` flawlessly! It is
annoying to release a package that contains all necessary files, but
crashes because of some obscure configuration option that does not quite
work well with the rest of the system. If you are only going to compile
packages for your own system, though, you do not need to worry too much
about this quality assurance step, as you are the only person suffering
from mistakes, after all.

Checking package sanity
-----------------------

After testing package functionality check it for errors using `namcap`_::

    $ namcap PKGBUILD
    $ namcap <package file name>.pkg.tar.xz

Namcap will:

* Check PKGBUILD contents for common errors and package file hierarchy for
   unnecessary/misplaced files
* Scan all ELF files in package using ``ldd``, automatically reporting
  which packages with required shared libraries are missing from
  ``depends`` and which can be omitted as transitive dependencies
* Heuristically search for missing and redundant dependencies
* and much more.

Get into the habit of checking your packages with namcap to avoid having to
fix the simplest mistakes after package submission.

Submitting packages to the AUR
==============================

Please read `Submitting packages`_ for a detailed description of the
submission process.

Summary
=======

* Download the source tarball of the software you want to package.
* Try compiling the package and installing it into an arbitrary directory.
* Copy over the prototype ``/usr/share/pacman/PKGBUILD.proto`` and rename it
  to ``PKGBUILD`` in a temporary working directory -- preferably ``~/abs/``.
* Edit the ``PKGBUILD`` according to the needs of your package.
* Run ``makepkg`` and see whether the resulting package is built correctly.
* If not, repeat the last two steps.

Warnings
--------

* Before you can automate the package building process, you should have
  done it manually at least once unless you know *exactly* what you are
  doing *in advance*, in which case you would not be reading this in the
  first place. Unfortunately, although a good bunch of program authors
  stick to the 3-step build cycle of::
  
      $ ./configure; make; make install
    
  this is not always the case, and things can get real ugly if you have to
  apply patches to make everything work at all. Rule of thumb: If you
  cannot get the program to compile from the source tarball, and make it
  install itself to a defined, temporary subdirectory, you do not even need
  to try packaging it. There is not any magic pixie dust in ``makepkg`` that
  makes source problems go away.

* In a few cases, the packages are not even available as source and you
  have to use something like ``sh installer.run`` to get it to work. You
  will have to do quite a bit of research (read READMEs, INSTALL
  instructions, man pages, perhaps ebuilds from Gentoo or other package
  installers, possibly even the MAKEFILEs or source code) to get it working.
  In some really bad cases, you have to edit the source files to get it to
  work at all. However, ``makepkg`` needs to be completely autonomous, with
  no user input. Therefore if you need to edit the makefiles, you may have
  to bundle a custom patch with the ``PKGBUILD`` and install it from inside
  the ``build()`` function, or you might have to issue some ``sed``
  commands from inside the ``build()`` function.

See Also
========
`How to correctly create a patch file`_


.. _base-devel: https://www.archlinux.org/groups/i686/base-devel/
.. _PKGBUILD article: https://wiki.archlinux.org/index.php/PKGBUILD
.. _bug 13214: https://bugs.archlinux.org/task/13214
.. _bash: http://en.wikipedia.org/wiki/Bash_(Unix_shell)
.. _documented: https://www.gnu.org/software/automake/manual/automake.html#Install
.. _namcap: https://wiki.archlinux.org/index.php/Namcap
.. _submitting packages: https://wiki.archlinux.org/index.php/AUR_User_Guidelines#Submitting_packages
.. _Package Guidelines: 
.. _How to correctly create a patch file: https://bbs.archlinux.org/viewtopic.php?id=91408
